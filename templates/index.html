<!DOCTYPE html>
<html>
<head>
    <title>Twitter Trends Scraper</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h2>Twitter Trends Scraper</h2>
        
        <div id="connection-status" class="status-panel">
            <h3>Connection Status</h3>
            <div class="status-item">
                <span>Twitter Connection:</span>
                <span id="twitter-status" class="status-indicator">Checking...</span>
                <button onclick="retryTwitter()" class="retry-button">Retry Twitter</button>
            </div>
            <div class="status-item">
                <span>ProxyMesh Connection:</span>
                <span id="proxy-status" class="status-indicator">Checking...</span>
                <button onclick="retryProxyMesh()" class="retry-button">Retry ProxyMesh</button>
            </div>
            <div id="error-message" class="error-message"></div>
        </div>
   
        <div class="scraper-section">
            <button onclick="runScraper()" id="scraper-button" class="run-button" disabled>
                Scrape Latest Trends
            </button>
            <div id="loading" class="loading-spinner" style="display: none;">
                Scraping trends...
            </div>
        </div>

        <div id="results" class="results-section" style="display: none;">
            <h3>Latest Twitter Trends</h3>
            <div class="trends-container">
                <div id="trends-list"></div>
                <div class="metadata">
                    <span id="scrape-time"></span>
                    <span id="ip-address"></span>
                </div>
            </div>
        </div>
    </div>
   
    <script>
        function updateConnectionStatus(status) {
            document.getElementById('twitter-status').textContent = status.twitter_connected ? 'Connected' : 'Disconnected';
            document.getElementById('twitter-status').className = 'status-indicator ' + (status.twitter_connected ? 'connected' : 'disconnected');
           
            document.getElementById('proxy-status').textContent = status.proxy_connected ? 'Connected' : 'Disconnected';
            document.getElementById('proxy-status').className = 'status-indicator ' + (status.proxy_connected ? 'connected' : 'disconnected');
           
            document.getElementById('error-message').textContent = status.error || '';
            document.getElementById('scraper-button').disabled = !(status.twitter_connected && status.proxy_connected);
        }
   
        function retryTwitter() {
            const button = document.querySelector('button[onclick="retryTwitter()"]');
            button.disabled = true;
            button.textContent = 'Retrying...';

            fetch('/retry_twitter')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'error') {
                        document.getElementById('error-message').textContent = data.message;
                    } else {
                        document.getElementById('twitter-status').textContent = data.twitter_connected ? 'Connected' : 'Disconnected';
                        document.getElementById('twitter-status').className = 'status-indicator ' + (data.twitter_connected ? 'connected' : 'disconnected');
                    }
                })
                .catch(error => {
                    document.getElementById('error-message').textContent = 'Failed to retry Twitter connection';
                })
                .finally(() => {
                    button.disabled = false;
                    button.textContent = 'Retry Twitter';
                    checkStatus();
                });
        }
   
        function retryProxyMesh() {
            const button = document.querySelector('button[onclick="retryProxyMesh()"]');
            button.disabled = true;
            button.textContent = 'Retrying...';

            fetch('/retry_proxymesh')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'error') {
                        document.getElementById('error-message').textContent = data.message;
                    } else {
                        document.getElementById('proxy-status').textContent = data.proxy_connected ? 'Connected' : 'Disconnected';
                        document.getElementById('proxy-status').className = 'status-indicator ' + (data.proxy_connected ? 'connected' : 'disconnected');
                    }
                })
                .catch(error => {
                    document.getElementById('error-message').textContent = 'Failed to retry ProxyMesh connection';
                })
                .finally(() => {
                    button.disabled = false;
                    button.textContent = 'Retry ProxyMesh';
                    checkStatus();
                });
        }

        function runScraper() {
            const button = document.getElementById('scraper-button');
            const loading = document.getElementById('loading');
            button.disabled = true;
            loading.style.display = 'block';
            document.getElementById('error-message').textContent = '';

            fetch('/trends')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'error') {
                        document.getElementById('error-message').textContent = data.message;
                        return;
                    }

                    const results = document.getElementById('results');
                    const trendsList = document.getElementById('trends-list');
                    const scrapeTime = document.getElementById('scrape-time');
                    const ipAddress = document.getElementById('ip-address');

                    // Clear previous results
                    trendsList.innerHTML = '';

                    // Create trending topics list
                    const trendingTopics = document.createElement('ol');
                    data.data.trends.forEach(trend => {
                        const li = document.createElement('li');
                        li.textContent = trend;
                        trendingTopics.appendChild(li);
                    });
                    trendsList.appendChild(trendingTopics);

                    // Update metadata
                    scrapeTime.textContent = `Scraped at: ${new Date(data.data.datetime.$date).toLocaleString()}`;
                    ipAddress.textContent = `IP: ${data.data.ip_address}`;

                    results.style.display = 'block';
                })
                .catch(error => {
                    document.getElementById('error-message').textContent = 'Failed to fetch trends';
                })
                .finally(() => {
                    button.disabled = false;
                    loading.style.display = 'none';
                });
        }
   
        function checkStatus() {
            fetch('/status')
                .then(response => response.json())
                .then(updateConnectionStatus)
                .catch(error => {
                    document.getElementById('error-message').textContent = 'Failed to check connection status';
                });
        }
   
        // Initial status check
        checkStatus();
        // Check status every 30 seconds
        setInterval(checkStatus, 30000);
    </script>
</body>
</html>